package models.factory;

import java.util.HashMap;
import java.util.Set;

import org.reflections.Reflections;

import com.google.inject.Singleton;

import models.securityvulnerabilities.SecurityVulnerability;
import models.securityvulnerabilities.Vulnerability;

@SuppressWarnings("unchecked")
@Singleton
public class VulnerabilityFactory {

    private static final String VULNERABILITY_DEFAULT_PACKAGE = "models.securityvulnerabilities.vulnerabilities";
    private static HashMap<String, Class<? extends SecurityVulnerability>> vulnerabilites = new HashMap<String, Class<? extends SecurityVulnerability>>();

    static {
        Reflections reflections = new Reflections(VULNERABILITY_DEFAULT_PACKAGE);
        Set<Class<?>> typesAnnotatedWith = reflections.getTypesAnnotatedWith(Vulnerability.class);
        for (Class<?> vulnerabilityClass : typesAnnotatedWith) {
            if (vulnerabilityClass.getInterfaces()[0] == SecurityVulnerability.class) {
                VulnerabilityFactory.registerVulnerability(vulnerabilityClass.getAnnotation(Vulnerability.class).value(),
                        (Class<? extends SecurityVulnerability>) vulnerabilityClass);
            }

        }
    }

    private static void registerVulnerability(String vulnerabilityKeyName, Class<? extends SecurityVulnerability> vulnerabilityClass) {
        VulnerabilityFactory.vulnerabilites.put(vulnerabilityKeyName, vulnerabilityClass);
    }

    public SecurityVulnerability createVulnerability(String vulnerabilityKeyName) {
        if (vulnerabilites.containsKey(vulnerabilityKeyName)) {
            Class<? extends SecurityVulnerability> vulnerabilityClass = VulnerabilityFactory.vulnerabilites.get(vulnerabilityKeyName);
            SecurityVulnerability vulnerabilityInstance = null;
            try {
                vulnerabilityInstance = vulnerabilityClass.newInstance();
            } catch (InstantiationException | IllegalAccessException e) {
                e.printStackTrace();
                // FIXME
            }

            return vulnerabilityInstance;
        } else {
            return null;
        }
    }
}
